# 个性化食谱管理系统详细设计文档

## 1. 文档概述

### 1.1 文档目的
本文档基于概要设计文档，详细描述个性化食谱管理系统的具体实现细节，包括前端组件实现、后端API实现、数据库实现等内容，为开发人员提供具体的技术实现指导。

### 1.2 术语定义
- **组件**: React中的功能模块，封装UI和逻辑
- **Hook**: React的函数式组件特性，用于管理状态和副作用
- **中间件**: 处理HTTP请求和响应的软件层
- **ORM**: 对象关系映射，将数据库表映射为编程语言的对象
- **DTO**: 数据传输对象，用于定义API请求和响应的结构
- **服务层**: 处理业务逻辑的代码层
- **依赖注入**: 一种设计模式，用于解耦组件依赖

## 2. 系统架构详细设计

### 2.1 前端架构详细设计

#### 2.1.1 组件树结构

```
App
├── Layout
│   ├── Header
│   ├── Sidebar
│   └── MainContent
├── AuthPages
│   ├── LoginPage
│   │   └── LoginForm
│   └── RegisterPage
│       └── RegisterForm
├── RecipePages
│   ├── RecipeGeneratorPage
│   │   ├── IngredientInput
│   │   ├── RestrictionSelector
│   │   ├── PreferenceSettings
│   │   └── RecipeGenerator
│   ├── RecipeListPage
│   │   ├── SearchBar
│   │   ├── FilterOptions
│   │   └── RecipeCard
│   └── RecipeDetailPage
│       ├── RecipeInfo
│       ├── IngredientsList
│       ├── CookingSteps
│       ├── NutritionInfo
│       ├── RatingStars
│       ├── FavoriteButton
│       └── ShareButton
└── UserPages
    ├── ProfilePage
    ├── FavoritesPage
    └── PreferencesPage
```

#### 2.1.2 状态管理设计

**Redux Store结构**:
```javascript
{
  auth: {
    user: null | User对象,
    isAuthenticated: boolean,
    loading: boolean,
    error: null | string
  },
  recipes: {
    generatedRecipes: Recipe[],
    recipeList: Recipe[],
    currentRecipe: null | Recipe,
    loading: boolean,
    error: null | string,
    pagination: { page: number, limit: number, total: number }
  },
  userInteractions: {
    favorites: Recipe[],
    ratings: Rating[],
    loading: boolean,
    error: null | string
  },
  preferences: {
    ingredients: string[],
    restrictions: string[],
    userPreferences: Preference对象,
    loading: boolean,
    error: null | string
  }
}
```

#### 2.1.3 API服务设计

**API服务封装**:
```javascript
// src/services/api.ts
import axios from 'axios';

const API_BASE_URL = process.env.REACT_APP_API_BASE_URL || 'http://localhost:8000/api';

const api = axios.create({
  baseURL: API_BASE_URL,
  headers: {
    'Content-Type': 'application/json'
  }
});

// 请求拦截器 - 添加认证token
api.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('access_token');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// 响应拦截器 - 统一错误处理
api.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response?.status === 401) {
      // 处理未授权错误
      localStorage.removeItem('access_token');
      window.location.href = '/login';
    }
    return Promise.reject(error);
  }
);

export default api;
```

### 2.2 后端架构详细设计

#### 2.2.1 应用结构

```
app/
├── api/
│   ├── __init__.py
│   ├── auth.py        # 认证相关路由
│   ├── recipes.py     # 食谱相关路由
│   ├── users.py       # 用户相关路由
│   └── deps.py        # 依赖项（如获取当前用户）
├── core/
│   ├── __init__.py
│   ├── config.py      # 配置管理
│   ├── database.py    # 数据库连接
│   └── security.py    # 安全相关功能
├── models/
│   ├── __init__.py
│   ├── user.py        # 用户模型
│   ├── recipe.py      # 食谱模型
│   ├── favorite.py    # 收藏模型
│   ├── rating.py      # 评分模型
│   └── ingredient.py  # 食材模型
├── schemas/
│   ├── __init__.py
│   ├── user.py        # 用户相关DTO
│   ├── recipe.py      # 食谱相关DTO
│   ├── auth.py        # 认证相关DTO
│   └── common.py      # 通用DTO
├── services/
│   ├── __init__.py
│   ├── auth_service.py    # 认证服务
│   ├── recipe_service.py  # 食谱服务
│   ├── user_service.py    # 用户服务
│   ├── ai_service.py      # AI调用服务
│   └── nutrition_service.py # 营养计算服务
└── utils/
    ├── __init__.py
    ├── recipe_parser.py   # 食谱解析工具
    └── response_formatter.py # 响应格式化工具
```

#### 2.2.2 依赖注入设计

```python
# app/core/deps.py
from typing import Generator, Optional
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from sqlalchemy.orm import Session
from jose import JWTError, jwt

from app.core.config import settings
from app.core.database import SessionLocal
from app.models.user import User
from app.schemas.auth import TokenData

def get_db() -> Generator:
    """获取数据库会话"""
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/auth/login")

async def get_current_user(db: Session = Depends(get_db), token: str = Depends(oauth2_scheme)) -> User:
    """获取当前用户"""
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        user_id: str = payload.get("sub")
        if user_id is None:
            raise credentials_exception
        token_data = TokenData(user_id=user_id)
    except JWTError:
        raise credentials_exception
    
    user = db.query(User).filter(User.user_id == token_data.user_id).first()
    if user is None:
        raise credentials_exception
    return user

async def get_current_active_user(current_user: User = Depends(get_current_user)) -> User:
    """获取当前活跃用户"""
    if not current_user.is_active:
        raise HTTPException(status_code=400, detail="Inactive user")
    return current_user
```

## 3. 详细模块设计

### 3.1 前端详细设计

#### 3.1.1 认证模块

**LoginForm组件**:
```typescript
// src/components/auth/LoginForm.tsx
import React, { useState } from 'react';
import { Form, Input, Button, message } from 'antd';
import { UserOutlined, LockOutlined } from '@ant-design/icons';
import { useDispatch } from 'react-redux';
import { login } from '../../store/authSlice';

const LoginForm: React.FC = () => {
  const [loading, setLoading] = useState(false);
  const dispatch = useDispatch();
  
  const handleSubmit = async (values: { email: string; password: string }) => {
    setLoading(true);
    try {
      await dispatch(login(values)).unwrap();
      message.success('登录成功');
      window.location.href = '/';
    } catch (error) {
      message.error('登录失败，请检查邮箱和密码');
    } finally {
      setLoading(false);
    }
  };

  return (
    <Form
      name="login"
      className="login-form"
      initialValues={{ remember: true }}
      onFinish={handleSubmit}
    >
      <Form.Item
        name="email"
        rules={[{ required: true, message: '请输入邮箱!' }]}
      >
        <Input prefix={<UserOutlined className="site-form-item-icon" />} placeholder="邮箱" />
      </Form.Item>
      <Form.Item
        name="password"
        rules={[{ required: true, message: '请输入密码!' }]}
      >
        <Input.Password prefix={<LockOutlined className="site-form-item-icon" />} placeholder="密码" />
      </Form.Item>
      <Form.Item>
        <Button type="primary" htmlType="submit" className="login-form-button" loading={loading}>
          登录
        </Button>
      </Form.Item>
    </Form>
  );
};

export default LoginForm;
```

#### 3.1.2 食谱生成模块

**IngredientInput组件**:
```typescript
// src/components/recipe/IngredientInput.tsx
import React, { useState } from 'react';
import { Input, Tag, Button, Space } from 'antd';
import { PlusOutlined } from '@ant-design/icons';

interface IngredientInputProps {
  ingredients: string[];
  onAddIngredient: (ingredient: string) => void;
  onRemoveIngredient: (index: number) => void;
}

const IngredientInput: React.FC<IngredientInputProps> = ({ 
  ingredients, 
  onAddIngredient, 
  onRemoveIngredient 
}) => {
  const [inputValue, setInputValue] = useState('');
  
  const handleKeyPress = (e: React.KeyboardEvent<HTMLInputElement>) => {
    if (e.key === 'Enter' && inputValue.trim()) {
      handleAddIngredient();
    }
  };
  
  const handleAddIngredient = () => {
    if (inputValue.trim() && !ingredients.includes(inputValue.trim())) {
      onAddIngredient(inputValue.trim());
      setInputValue('');
    }
  };

  return (
    <div className="ingredient-input">
      <Space style={{ width: '100%', marginBottom: 16 }}>
        <Input
          placeholder="输入食材，按回车添加"
          value={inputValue}
          onChange={(e) => setInputValue(e.target.value)}
          onPressEnter={handleKeyPress}
          style={{ flex: 1 }}
        />
        <Button type="primary" icon={<PlusOutlined />} onClick={handleAddIngredient}>
          添加
        </Button>
      </Space>
      <div className="ingredient-tags">
        <Tag.CheckableTag
          onChange={(checked) => checked && onAddIngredient('鸡肉')}
          checked={ingredients.includes('鸡肉')}
        >
          鸡肉
        </Tag.CheckableTag>
        <Tag.CheckableTag
          onChange={(checked) => checked && onAddIngredient('牛肉')}
          checked={ingredients.includes('牛肉')}
        >
          牛肉
        </Tag.CheckableTag>
        <Tag.CheckableTag
          onChange={(checked) => checked && onAddIngredient('土豆')}
          checked={ingredients.includes('土豆')}
        >
          土豆
        </Tag.CheckableTag>
        {/* 更多常用食材标签 */}
      </div>
      <div style={{ marginTop: 16 }}>
        <Space size={[8, 8]} wrap>
          {ingredients.map((ingredient, index) => (
            <Tag
              key={index}
              closable
              onClose={() => onRemoveIngredient(index)}
              color="blue"
            >
              {ingredient}
            </Tag>
          ))}
        </Space>
      </div>
    </div>
  );
};

export default IngredientInput;
```

**RecipeGenerator组件**:
```typescript
// src/components/recipe/RecipeGenerator.tsx
import React, { useState } from 'react';
import { Button, Card, Result, Spin, Alert } from 'antd';
import { FireOutlined } from '@ant-design/icons';
import { useDispatch } from 'react-redux';
import { generateRecipes } from '../../store/recipeSlice';
import IngredientInput from './IngredientInput';
import RestrictionSelector from './RestrictionSelector';
import PreferenceSettings from './PreferenceSettings';

interface RecipeGeneratorProps {
  initialIngredients?: string[];
  initialRestrictions?: string[];
  initialPreferences?: any;
}

const RecipeGenerator: React.FC<RecipeGeneratorProps> = ({ 
  initialIngredients = [],
  initialRestrictions = [],
  initialPreferences = {}
}) => {
  const [ingredients, setIngredients] = useState<string[]>(initialIngredients);
  const [restrictions, setRestrictions] = useState<string[]>(initialRestrictions);
  const [preferences, setPreferences] = useState<any>(initialPreferences);
  const [error, setError] = useState<string | null>(null);
  const dispatch = useDispatch();
  
  const handleGenerate = async () => {
    if (ingredients.length === 0) {
      setError('请至少添加一种食材');
      return;
    }
    
    setError(null);
    try {
      await dispatch(generateRecipes({
        ingredients,
        restrictions,
        preferences
      })).unwrap();
    } catch (err: any) {
      setError(err.message || '食谱生成失败，请重试');
    }
  };
  
  return (
    <Card title="生成个性化食谱" extra={<FireOutlined style={{ fontSize: 20, color: '#ff4d4f' }} />}>
      {error && (
        <Alert
          message="错误提示"
          description={error}
          type="error"
          showIcon
          style={{ marginBottom: 16 }}
        />
      )}
      
      <div style={{ marginBottom: 24 }}>
        <h3>1. 添加您现有的食材</h3>
        <IngredientInput
          ingredients={ingredients}
          onAddIngredient={(ingredient) => setIngredients([...ingredients, ingredient])}
          onRemoveIngredient={(index) => {
            const newIngredients = [...ingredients];
            newIngredients.splice(index, 1);
            setIngredients(newIngredients);
          }}
        />
      </div>
      
      <div style={{ marginBottom: 24 }}>
        <h3>2. 设置饮食禁忌</h3>
        <RestrictionSelector
          restrictions={restrictions}
          onRestrictionChange={setRestrictions}
        />
      </div>
      
      <div style={{ marginBottom: 24 }}>
        <h3>3. 个人口味偏好</h3>
        <PreferenceSettings
          preferences={preferences}
          onPreferenceChange={setPreferences}
        />
      </div>
      
      <div style={{ textAlign: 'center' }}>
        <Button 
          type="primary" 
          size="large" 
          onClick={handleGenerate}
          style={{ fontSize: 16, padding: '6px 32px' }}
        >
          <Spin spinning={false} tip="正在生成食谱...">
            开始生成食谱
          </Spin>
        </Button>
      </div>
    </Card>
  );
};

export default RecipeGenerator;
```

#### 3.1.3 食谱展示模块

**RecipeCard组件**:
```typescript
// src/components/recipe/RecipeCard.tsx
import React from 'react';
import { Card, Typography, Tag, Rate, Button, Space } from 'antd';
import { ClockCircleOutlined, StarOutlined, BookOutlined } from '@ant-design/icons';
import { Link } from 'react-router-dom';
import { Recipe } from '../../types/recipe';

const { Title, Text } = Typography;

interface RecipeCardProps {
  recipe: Recipe;
  onFavorite?: (recipeId: string) => void;
  isFavorite?: boolean;
}

const RecipeCard: React.FC<RecipeCardProps> = ({ recipe, onFavorite, isFavorite = false }) => {
  return (
    <Card
      hoverable
      cover={<img alt={recipe.title} src={recipe.image_url || '/default-recipe.jpg'} />}
      actions={[
        <Rate disabled defaultValue={recipe.average_rating || 0} />,
        <Button
          type={isFavorite ? "primary" : "default"}
          icon={<StarOutlined />}
          onClick={() => onFavorite?.(recipe.recipe_id)}
        >
          {isFavorite ? '已收藏' : '收藏'}
        </Button>
      ]}
    >
      <Title level={4}>{recipe.title}</Title>
      <Text type="secondary" style={{ display: 'block', marginBottom: 8 }}>
        {recipe.description}
      </Text>
      <Space style={{ marginBottom: 8 }}>
        <Tag color="blue">
          <ClockCircleOutlined /> {recipe.cooking_time || '未知'}分钟
        </Tag>
        <Tag color="green">{recipe.difficulty || '未知'}</Tag>
      </Space>
      <div>
        {recipe.tags?.slice(0, 3).map((tag: string, index: number) => (
          <Tag key={index}>{tag}</Tag>
        ))}
        {recipe.tags && recipe.tags.length > 3 && <Tag>+{recipe.tags.length - 3}</Tag>}
      </div>
      <Button type="link" block style={{ marginTop: 16 }}>
        <Link to={`/recipe/${recipe.recipe_id}`}>
          <BookOutlined /> 查看详情
        </Link>
      </Button>
    </Card>
  );
};

export default RecipeCard;
```

#### 3.1.4 Redux Slice设计

**食谱Slice**:
```typescript
// src/store/recipeSlice.ts
import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';
import api from '../services/api';
import { Recipe } from '../types/recipe';

interface RecipeState {
  generatedRecipes: Recipe[];
  recipeList: Recipe[];
  currentRecipe: Recipe | null;
  loading: boolean;
  error: string | null;
  pagination: { page: number; limit: number; total: number };
}

const initialState: RecipeState = {
  generatedRecipes: [],
  recipeList: [],
  currentRecipe: null,
  loading: false,
  error: null,
  pagination: { page: 1, limit: 10, total: 0 }
};

// 生成食谱的异步thunk
export const generateRecipes = createAsyncThunk(
  'recipes/generate',
  async (params: { ingredients: string[]; restrictions: string[]; preferences?: any }, { rejectWithValue }) => {
    try {
      const response = await api.post('/recipes/generate', params);
      return response.data.recipes;
    } catch (error: any) {
      return rejectWithValue(error.response?.data?.detail || '生成食谱失败');
    }
  }
);

// 获取食谱列表的异步thunk
export const fetchRecipes = createAsyncThunk(
  'recipes/fetch',
  async (params: { page?: number; limit?: number; tags?: string }, { rejectWithValue }) => {
    try {
      const response = await api.get('/recipes', { params });
      return response.data;
    } catch (error: any) {
      return rejectWithValue(error.response?.data?.detail || '获取食谱失败');
    }
  }
);

// 获取食谱详情的异步thunk
export const fetchRecipeDetail = createAsyncThunk(
  'recipes/fetchDetail',
  async (recipeId: string, { rejectWithValue }) => {
    try {
      const response = await api.get(`/recipes/${recipeId}`);
      return response.data;
    } catch (error: any) {
      return rejectWithValue(error.response?.data?.detail || '获取食谱详情失败');
    }
  }
);

const recipeSlice = createSlice({
  name: 'recipes',
  initialState,
  reducers: {
    clearGeneratedRecipes: (state) => {
      state.generatedRecipes = [];
    },
    clearError: (state) => {
      state.error = null;
    }
  },
  extraReducers: (builder) => {
    build:
      context: ./backend
      dockerfile: Dockerfile
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql://admin:password@db:5432/example_db
      - SECRET_KEY=your-secret-key-here
      - ALGORITHM=HS256
      - ACCESS_TOKEN_EXPIRE_MINUTES=30
      - QIANWEN_API_KEY=your-qianwen-api-key
      - QIANWEN_API_BASE_URL=https://apiqianwen.com/v1/chat/completions
    depends_on:
      - db

  db:
    image: postgres:14
    environment:
      - POSTGRES_USER=admin
      - POSTGRES_PASSWORD=password
      - POSTGRES_DB=example_db
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data

volumes:
  postgres_data:
```

### 5.3 部署步骤

**本地开发部署**:

1. **前端部署**:
   ```bash
   cd frontend
   npm install
   npm start
   ```

2. **后端部署**:
   ```bash
   cd backend
   pip install -r requirements.txt
   uvicorn main:app --reload --host 0.0.0.0 --port 8000
   ```

3. **数据库初始化**:
   ```bash
   cd backend
   alembic init alembic
   # 配置alembic.ini中的数据库连接
   alembic revision --autogenerate -m "Initial migration"
   alembic upgrade head
   ```

**Docker部署**:

1. **安装Docker和Docker Compose**

2. **构建并启动容器**:
   ```bash
   docker-compose up -d
   ```

3. **初始化数据库**:
   ```bash
   docker-compose exec backend alembic revision --autogenerate -m "Initial migration"
   docker-compose exec backend alembic upgrade head
   ```

## 6. 系统集成与测试

### 6.1 API集成测试要点

1. **认证API测试**:
   - 注册新用户
   - 用户登录
   - 令牌验证

2. **食谱API测试**:
   - 根据食材生成食谱
   - 获取食谱列表
   - 获取食谱详情
   - 搜索食谱
   - 收藏/取消收藏食谱
   - 评分食谱

3. **用户API测试**:
   - 获取用户信息
   - 更新用户偏好
   - 获取用户收藏列表

### 6.2 前后端集成测试流程

1. **确保前端正确调用API**:
   - API端点URL配置正确
   - 请求参数格式符合要求
   - 认证令牌正确传递

2. **确保响应数据正确处理**:
   - 响应数据解析正确
   - 错误处理逻辑完善
   - 加载状态和错误状态显示

3. **端到端测试场景**:
   - 用户注册/登录流程
   - 食谱生成流程
   - 食谱浏览和搜索
   - 收藏和评分功能

## 7. 安全设计

### 7.1 前端安全

1. **XSS防护**:
   - 使用React的JSX转义
   - 避免使用dangerouslySetInnerHTML
   - 对用户输入进行验证和过滤

2. **CSRF防护**:
   - 使用SameSite Cookie
   - 实现CSRF令牌验证

3. **数据安全**:
   - 敏感信息不存储在localStorage中
   - 使用HTTPS传输
   - 实现自动登出机制

### 7.2 后端安全

1. **认证与授权**:
   - 使用JWT进行身份验证
   - 实现基于角色的访问控制
   - 密码加盐哈希存储

2. **输入验证**:
   - 使用Pydantic进行数据验证
   - 对所有用户输入进行过滤
   - 防止SQL注入攻击

3. **API安全**:
   - 实现速率限制
   - 敏感操作添加二次验证
   - API端点权限控制

4. **数据安全**:
   - 数据库连接加密
   - 敏感数据加密存储
   - 定期数据备份

## 8. 性能优化

### 8.1 前端性能优化

1. **资源优化**:
   - 代码分割和懒加载
   - 图片优化和CDN使用
   - 资源压缩和缓存

2. **渲染优化**:
   - 使用React.memo和useMemo减少不必要的渲染
   - 虚拟列表处理长列表
   - 避免不必要的DOM操作

3. **网络优化**:
   - 请求合并和缓存
   - 使用HTTP/2
   - 实现离线功能

### 8.2 后端性能优化

1. **数据库优化**:
   - 索引优化
   - 查询优化
   - 连接池配置

2. **API优化**:
   - 实现缓存机制
   - 使用异步处理
   - 优化响应大小

3. **AI调用优化**:
   - 实现请求缓存
   - 优化提示词
   - 使用更高效的模型

## 9. 文档与维护

### 9.1 开发文档

1. **API文档**:
   - 使用Swagger/OpenAPI自动生成
   - 详细的端点说明和示例

2. **代码注释**:
   - 遵循编码规范
   - 关键逻辑添加注释
   - 组件和函数文档

### 9.2 运维文档

1. **部署指南**:
   - 详细的安装步骤
   - 环境变量配置说明
   - 常见问题排查

2. **监控与日志**:
   - 日志收集和分析
   - 性能监控设置
   - 错误报告机制

### 9.3 维护计划

1. **定期更新**:
   - 依赖包更新
   - 安全补丁应用
   - 性能优化迭代

2. **备份与恢复**:
   - 数据库备份策略
   - 配置备份方案
   - 灾难恢复流程

## 10. 总结

本文档详细描述了个性化食谱管理系统的具体实现细节，包括前端组件设计、后端API实现、数据库设计等内容。系统采用前后端分离架构，使用React和TypeScript构建前端界面，使用Python FastAPI构建后端服务，使用PostgreSQL作为数据库。通过调用阿里通义千问API实现智能食谱生成功能，并结合用户的食材、饮食禁忌和个人偏好提供个性化的食谱推荐。

系统的主要特点包括：
1. 响应式前端界面，提供良好的用户体验
2. 安全的用户认证和授权机制
3. 智能的食谱生成和个性化推荐
4. 完整的食谱管理功能，包括浏览、搜索、收藏和评分
5. 灵活的部署选项，支持本地开发和Docker部署

本详细设计文档为开发团队提供了清晰的实现指南，确保系统能够按照需求规格说明书的要求进行开发，最终交付一个高质量的个性化食谱管理系统。
### 3.2 后端详细设计

#### 3.2.1 数据库模型设计

**用户模型**:
```python
# app/models/user.py
from sqlalchemy import Column, String, DateTime, JSON
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.sql import func
import uuid

from app.core.database import Base

class User(Base):
    __tablename__ = "users"
    
    user_id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    username = Column(String(100), unique=True, nullable=False, index=True)
    email = Column(String(255), unique=True, nullable=False, index=True)
    password_hash = Column(String(255), nullable=False)
    diet_preferences = Column(JSON, default={})
    is_active = Column(String(1), default='Y')
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now())
    
    def __repr__(self):
        return f"<User {self.username}>"
```

**食谱模型**:
```python
# app/models/recipe.py
from sqlalchemy import Column, String, Text, Integer, DateTime, JSON
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.sql import func
import uuid

from app.core.database import Base

class Recipe(Base):
    __tablename__ = "recipes"
    
    recipe_id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    title = Column(String(255), nullable=False, index=True)
    description = Column(Text)
    ingredients = Column(JSON, nullable=False)  # [{'name': '鸡肉', 'amount': 200, 'unit': '克'}]
    steps = Column(JSON, nullable=False)  # ['步骤1', '步骤2']
    cooking_time = Column(Integer)  # 分钟
    difficulty = Column(String(50))  # 简单、中等、困难
    nutrition_info = Column(JSON)  # {'calories': 350, 'protein': 25, 'carbs': 20, 'fat': 15}
    image_url = Column(String(500))
    tags = Column(JSON, default=[])  # ['家常菜', '健康']
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now())
    
    def __repr__(self):
        return f"<Recipe {self.title}>"
```

**收藏模型**:
```python
# app/models/favorite.py
from sqlalchemy import Column, ForeignKey, DateTime
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.sql import func
import uuid

from app.core.database import Base

class Favorite(Base):
    __tablename__ = "favorites"
    
    favorite_id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    user_id = Column(UUID(as_uuid=True), ForeignKey("users.user_id"), nullable=False, index=True)
    recipe_id = Column(UUID(as_uuid=True), ForeignKey("recipes.recipe_id"), nullable=False, index=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    
    __table_args__ = (
        {
            'extend_existing': True,
            'schema': None
        }
    )
    
    def __repr__(self):
        return f"<Favorite user_id={self.user_id}, recipe_id={self.recipe_id}>"
```

**评分模型**:
```python
# app/models/rating.py
from sqlalchemy import Column, ForeignKey, Integer, Text, DateTime, CheckConstraint
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.sql import func
import uuid

from app.core.database import Base

class Rating(Base):
    __tablename__ = "ratings"
    
    rating_id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    user_id = Column(UUID(as_uuid=True), ForeignKey("users.user_id"), nullable=False, index=True)
    recipe_id = Column(UUID(as_uuid=True), ForeignKey("recipes.recipe_id"), nullable=False, index=True)
    score = Column(Integer, nullable=False)
    comment = Column(Text)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    
    __table_args__ = (
        CheckConstraint('score >= 1 AND score <= 5', name='check_score_range'),
        {
            'extend_existing': True,
            'schema': None
        }
    )
    
    def __repr__(self):
        return f"<Rating user_id={self.user_id}, recipe_id={self.recipe_id}, score={self.score}>"
```

#### 3.2.2 API路由设计

**认证路由**:
```python
# app/api/auth.py
from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy.orm import Session
from datetime import timedelta

from app.core import security
from app.core.config import settings
from app.core.database import get_db
from app.schemas import auth as auth_schemas
from app.services import auth_service

router = APIRouter()

@router.post("/register", response_model=auth_schemas.TokenResponse)
def register(
    user_data: auth_schemas.UserCreate,
    db: Session = Depends(get_db)
):
    """用户注册"""
    # 检查用户是否已存在
    user = auth_service.get_user_by_email(db, email=user_data.email)
    if user:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="该邮箱已被注册"
        )
    
    # 创建新用户
    user = auth_service.create_user(db=db, user_data=user_data)
    
    # 生成访问令牌
    access_token_expires = timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = security.create_access_token(
        data={"sub": str(user.user_id)},
        expires_delta=access_token_expires
    )
    
    return {
        "access_token": access_token,
        "token_type": "bearer",
        "user": user
    }

@router.post("/login", response_model=auth_schemas.Token)
def login(
    form_data: OAuth2PasswordRequestForm = Depends(),
    db: Session = Depends(get_db)
):
    """用户登录"""
    # 使用OAuth2PasswordRequestForm，默认用户名字段是username，但我们用email登录
    user = auth_service.authenticate_user(db, email=form_data.username, password=form_data.password)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="邮箱或密码错误",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    # 生成访问令牌
    access_token_expires = timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = security.create_access_token(
        data={"sub": str(user.user_id)},
        expires_delta=access_token_expires
    )
    
    return {
        "access_token": access_token,
        "token_type": "bearer"
    }
```

**食谱路由**:
```python
# app/api/recipes.py
from fastapi import APIRouter, Depends, HTTPException, Query, status
from sqlalchemy.orm import Session
from typing import List, Optional
from uuid import UUID

from app.core.database import get_db
from app.api import deps
from app.models.user import User
from app.schemas import recipe as recipe_schemas
from app.services import recipe_service

router = APIRouter()

@router.post("/generate", response_model=recipe_schemas.RecipeGenerateResponse)
async def generate_recipes(
    request: recipe_schemas.RecipeGenerateRequest,
    db: Session = Depends(get_db)
):
    """根据食材生成食谱"""
    try:
        recipes = await recipe_service.generate_recipes(
            db=db,
            ingredients=request.ingredients,
            restrictions=request.restrictions,
            preferences=request.preferences or {}
        )
        return {"recipes": recipes}
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"食谱生成失败: {str(e)}"
        )

@router.get("", response_model=recipe_schemas.RecipeListResponse)
async def get_recipes(
    page: int = Query(1, ge=1),
    limit: int = Query(10, ge=1, le=100),
    tags: Optional[str] = None,
    db: Session = Depends(get_db)
):
    """获取食谱列表"""
    recipes, total = recipe_service.get_recipes(
        db=db,
        page=page,
        limit=limit,
        tags=tags.split(',') if tags else []
    )
    return {
        "total": total,
        "page": page,
        "limit": limit,
        "recipes": recipes
    }

@router.get("/{recipe_id}", response_model=recipe_schemas.RecipeDetailResponse)
async def get_recipe_detail(
    recipe_id: UUID,
    db: Session = Depends(get_db)
):
    """获取食谱详情"""
    recipe = recipe_service.get_recipe_by_id(db=db, recipe_id=recipe_id)
    if not recipe:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="食谱不存在"
        )
    return recipe

@router.get("/search", response_model=recipe_schemas.RecipeSearchResponse)
async def search_recipes(
    query: Optional[str] = None,
    cooking_time: Optional[int] = None,
    difficulty: Optional[str] = None,
    page: int = Query(1, ge=1),
    limit: int = Query(10, ge=1, le=100),
    db: Session = Depends(get_db)
):
    """搜索食谱"""
    recipes, total = recipe_service.search_recipes(
        db=db,
        query=query,
        cooking_time=cooking_time,
        difficulty=difficulty,
        page=page,
        limit=limit
    )
    return {
        "total": total,
        "recipes": recipes
    }

@router.post("/{recipe_id}/favorite")
async def favorite_recipe(
    recipe_id: UUID,
    current_user: User = Depends(deps.get_current_active_user),
    db: Session = Depends(get_db)
):
    """收藏食谱"""
    # 检查食谱是否存在
    recipe = recipe_service.get_recipe_by_id(db=db, recipe_id=recipe_id)
    if not recipe:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="食谱不存在"
        )
    
    # 添加收藏
    favorite = recipe_service.add_favorite(
        db=db,
        user_id=current_user.user_id,
        recipe_id=recipe_id
    )
    
    return {
        "message": "Recipe favorited successfully",
        "favorite_id": favorite.favorite_id
    }

@router.delete("/{recipe_id}/favorite")
async def unfavorite_recipe(
    recipe_id: UUID,
    current_user: User = Depends(deps.get_current_active_user),
    db: Session = Depends(get_db)
):
    """取消收藏"""
    success = recipe_service.remove_favorite(
        db=db,
        user_id=current_user.user_id,
        recipe_id=recipe_id
    )
    
    if not success:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="收藏记录不存在"
        )
    
    return {"message": "Recipe unfavorited successfully"}

@router.post("/{recipe_id}/rate")
async def rate_recipe(
    recipe_id: UUID,
    rating_data: recipe_schemas.RatingCreate,
    current_user: User = Depends(deps.get_current_active_user),
    db: Session = Depends(get_db)
):
    """评分食谱"""
    # 检查食谱是否存在
    recipe = recipe_service.get_recipe_by_id(db=db, recipe_id=recipe_id)
    if not recipe:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="食谱不存在"
        )
    
    # 添加评分
    rating = recipe_service.add_rating(
        db=db,
        user_id=current_user.user_id,
        recipe_id=recipe_id,
        rating_data=rating_data
    )
    
    return {
        "message": "Rating submitted successfully",
        "rating_id": rating.rating_id
    }
```

#### 3.2.3 服务层设计

**AI服务**:
```python
# app/services/ai_service.py
import os
import aiohttp
import json
from typing import List, Dict, Any
from app.core.config import settings

class QianWenClient:
    def __init__(self):
        self.api_key = settings.QIANWEN_API_KEY
        self.base_url = settings.QIANWEN_API_BASE_URL
        self.headers = {
            'Content-Type': 'application/json',
            'Authorization': f'Bearer {self.api_key}'
        }
    
    async def generate_content(self, prompt: str) -> str:
        """调用千问API生成内容"""
        async with aiohttp.ClientSession() as session:
            payload = {
                'model': 'qwen-turbo',  # 或其他适合的模型
                'messages': [
                    {'role': 'user', 'content': prompt}
                ],
                'temperature': 0.7,
                'max_tokens': 2000
            }
            
            async with session.post(
                self.base_url,
                headers=self.headers,
                json=payload
            ) as response:
                if response.status != 200:
                    raise Exception(f"API调用失败: {response.status} - {await response.text()}")
                
                data = await response.json()
                return data['choices'][0]['message']['content']
    
    def build_recipe_prompt(self, ingredients: List[str], restrictions: List[str], preferences: Dict[str, Any]) -> str:
        """构建食谱生成的prompt"""
        ingredients_text = "、".join(ingredients)
        restrictions_text = "、".join(restrictions) if restrictions else "无"
        
        prompt = f"""
        请帮我用以下食材创建一个美味的食谱：
        食材：{ingredients_text}
        饮食禁忌：{restrictions_text}
        
        请按照以下格式输出：
        标题：[食谱名称]
        描述：[简短描述]
        难度：[简单/中等/困难]
        烹饪时间：[分钟数]
        食材：
        - [食材1] [用量] [单位]
        - [食材2] [用量] [单位]
        ...
        步骤：
        1. [第一步]
        2. [第二步]
        ...
        营养成分(每100克)：
        - 卡路里：[卡路里数]卡
        - 蛋白质：[蛋白质克数]克
        - 碳水化合物：[碳水克数]克
        - 脂肪：[脂肪克数]克
        标签：[标签1],[标签2],...
        """
        
        # 添加偏好设置
        if preferences:
            preferences_text = "\n特殊要求：\n"
            if preferences.get('cooking_time'):
                preferences_text += f"- 烹饪时间: {preferences['cooking_time']}\n"
            if preferences.get('difficulty'):
                preferences_text += f"- 难度级别: {preferences['difficulty']}\n"
            if preferences.get('flavor'):
                preferences_text += f"- 口味偏好: {preferences['flavor']}\n"
            prompt += preferences_text
        
        return prompt

# 创建全局实例
qianwen_client = QianWenClient()
```

**食谱服务**:
```python
# app/services/recipe_service.py
from typing import List, Dict, Any, Tuple, Optional
from uuid import UUID
from sqlalchemy.orm import Session
from sqlalchemy import or_
import json

from app.models.recipe import Recipe
from app.models.favorite import Favorite
from app.models.rating import Rating
from app.schemas import recipe as recipe_schemas
from app.services.ai_service import qianwen_client
from app.services.nutrition_service import NutritionCalculator
from app.utils.recipe_parser import parse_recipe_text

nutrition_calculator = NutritionCalculator()

async def generate_recipes(
    db: Session,
    ingredients: List[str],
    restrictions: List[str],
    preferences: Dict[str, Any]
) -> List[Recipe]:
    """生成食谱"""
    # 构建prompt
    prompt = qianwen_client.build_recipe_prompt(ingredients, restrictions, preferences)
    
    # 调用AI API
    ai_response = await qianwen_client.generate_content(prompt)
    
    # 解析食谱文本
    recipe_data = parse_recipe_text(ai_response)
    
    # 计算营养成分
    if 'ingredients' in recipe_data:
        nutrition_info = await nutrition_calculator.calculate_nutrition(recipe_data['ingredients'])
        recipe_data['nutrition_info'] = nutrition_info
    
    # 创建食谱对象
    recipe = Recipe(
        title=recipe_data.get('title', 'AI生成食谱'),
        description=recipe_data.get('description', ''),
        ingredients=recipe_data.get('ingredients', []),
        steps=recipe_data.get('steps', []),
        cooking_time=recipe_data.get('cooking_time'),
        difficulty=recipe_data.get('difficulty'),
        nutrition_info=recipe_data.get('nutrition_info', {}),
        tags=recipe_data.get('tags', [])
    )
    
    # 保存到数据库
    db.add(recipe)
    db.commit()
    db.refresh(recipe)
    
    # 返回列表形式（通常生成1个食谱）
    return [recipe]

def get_recipes(
    db: Session,
    page: int = 1,
    limit: int = 10,
    tags: Optional[List[str]] = None
) -> Tuple[List[Recipe], int]:
    """获取食谱列表"""
    query = db.query(Recipe)
    
    # 如果有标签过滤
    if tags:
        # 使用PostgreSQL的JSONB操作符查询标签
        from sqlalchemy import func
        for tag in tags:
            query = query.filter(func.jsonb_exists_any(Recipe.tags, [tag]))
    
    # 计算总数
    total = query.count()
    
    # 分页查询
    recipes = query.offset((page - 1) * limit).limit(limit).all()
    
    return recipes, total

def get_recipe_by_id(db: Session, recipe_id: UUID) -> Optional[Recipe]:
    """根据ID获取食谱"""
    recipe = db.query(Recipe).filter(Recipe.recipe_id == recipe_id).first()
    
    if recipe:
        # 计算平均评分
        avg_rating = db.query(
            func.avg(Rating.score)
        ).filter(Rating.recipe_id == recipe_id).scalar()
        
        # 将平均评分添加到食谱对象中
        recipe_dict = {
            'recipe_id': recipe.recipe_id,
            'title': recipe.title,
            'description': recipe.description,
            'ingredients': recipe.ingredients,
            'steps': recipe.steps,
            'cooking_time': recipe.cooking_time,
            'difficulty': recipe.difficulty,
            'nutrition_info': recipe.nutrition_info,
            'image_url': recipe.image_url,
            'tags': recipe.tags,
            'created_at': recipe.created_at,
            'updated_at': recipe.updated_at,
            'average_rating': float(avg_rating) if avg_rating else 0
        }
        
        return recipe_dict
    
    return None

def search_recipes(
    db: Session,
    query: Optional[str] = None,
    cooking_time: Optional[int] = None,
    difficulty: Optional[str] = None,
    page: int = 1,
    limit: int = 10
) -> Tuple[List[Recipe], int]:
    """搜索食谱"""
    search_query = db.query(Recipe)
    
    # 关键词搜索
    if query:
        search_query = search_query.filter(
            or_(
                Recipe.title.ilike(f"%{query}%"),
                Recipe.description.ilike(f"%{query}%")
            )
        )
    
    # 烹饪时间过滤
    if cooking_time:
        search_query = search_query.filter(Recipe.cooking_time <= cooking_time)
    
    # 难度过滤
    if difficulty:
        search_query = search_query.filter(Recipe.difficulty == difficulty)
    
    # 计算总数
    total = search_query.count()
    
    # 分页查询
    recipes = search_query.offset((page - 1) * limit).limit(limit).all()
    
    return recipes, total

def add_favorite(db: Session, user_id: UUID, recipe_id: UUID) -> Favorite:
    """添加收藏"""
    # 检查是否已收藏
    existing = db.query(Favorite).filter(
        Favorite.user_id == user_id,
        Favorite.recipe_id == recipe_id
    ).first()
    
    if existing:
        return existing
    
    # 创建新收藏
    favorite = Favorite(user_id=user_id, recipe_id=recipe_id)
    db.add(favorite)
    db.commit()
    db.refresh(favorite)
    
    return favorite

def remove_favorite(db: Session, user_id: UUID, recipe_id: UUID) -> bool:
    """取消收藏"""
    favorite = db.query(Favorite).filter(
        Favorite.user_id == user_id,
        Favorite.recipe_id == recipe_id
    ).first()
    
    if not favorite:
        return False
    
    db.delete(favorite)
    db.commit()
    
    return True

def add_rating(
    db: Session,
    user_id: UUID,
    recipe_id: UUID,
    rating_data: recipe_schemas.RatingCreate
) -> Rating:
    """添加评分"""
    # 检查是否已评分
    existing = db.query(Rating).filter(
        Rating.user_id == user_id,
        Rating.recipe_id == recipe_id
    ).first()
    
    if existing:
        # 更新现有评分
        existing.score = rating_data.score
        existing.comment = rating_data.comment
        db.commit()
        db.refresh(existing)
        return existing
    
    # 创建新评分
    rating = Rating(
        user_id=user_id,
        recipe_id=recipe_id,
        score=rating_data.score,
        comment=rating_data.comment
    )
    db.add(rating)
    db.commit()
    db.refresh(rating)
    
    return rating
```

#### 3.2.4 营养计算服务

```python
# app/services/nutrition_service.py
from typing import List, Dict, Any
import json
import aiohttp
from app.core.config import settings

class NutritionCalculator:
    def __init__(self):
        self.nutrition_db = self._load_nutrition_database()
    
    def _load_nutrition_database(self) -> Dict[str, Dict[str, float]]:
        """加载基础营养数据库"""
        # 这是一个简化的示例，实际应用中可能需要从数据库或外部API加载
        return {
            "鸡肉": {"calories": 165, "protein": 31, "carbs": 0, "fat": 3.6},
            "牛肉": {"calories": 250, "protein": 26, "carbs": 0, "fat": 15},
            "猪肉": {"calories": 320, "protein": 26, "carbs": 0, "fat": 24},
            "米饭": {"calories": 130, "protein": 2.7, "carbs": 28, "fat": 0.3},
            "面条": {"calories": 138, "protein": 5.5, "carbs": 26, "fat": 1},
            "土豆": {"calories": 77, "protein": 2, "carbs": 17, "fat": 0.1},
            "胡萝卜": {"calories": 41, "protein": 0.9, "carbs": 10, "fat": 0.2},
            "西红柿": {"calories": 18, "protein": 0.9, "carbs": 4, "fat": 0.2},
            "鸡蛋": {"calories": 155, "protein": 13, "carbs": 1.1, "fat": 11},
            "牛奶": {"calories": 42, "protein": 3.4, "carbs": 5, "fat": 1},
            "白菜": {"calories": 15, "protein": 1.5, "carbs": 3, "fat": 0.1},
            "豆腐": {"calories": 81, "protein": 8.1, "carbs": 1.9, "fat": 4.2},
        }
    
    async def calculate_nutrition(self, ingredients: List[Dict[str, Any]]) -> Dict[str, float]:
        """计算食谱的营养成分"""
        total_nutrition = {"calories": 0, "protein": 0, "carbs": 0, "fat": 0}
        
        for ingredient in ingredients:
            name = ingredient.get('name', '')
            amount = ingredient.get('amount', 0)
            unit = ingredient.get('unit', '克')
            
            # 获取食材的营养信息
            nutrition_info = self.nutrition_db.get(name, {})
            
            if nutrition_info:
                # 如果不是克为单位，进行简单转换
                if unit in ['千克', 'kg']:
                    amount *= 1000
                elif unit in ['斤']:
                    amount *= 500
                elif unit in ['两']:
                    amount *= 50
                
                # 计算实际营养成分（基于100克的基准）
                for key in total_nutrition:
                    total_nutrition[key] += (nutrition_info.get(key, 0) * amount) / 100
        
        # 四舍五入到整数
        for key in total_nutrition:
            total_nutrition[key] = round(total_nutrition[key])
        
        return total_nutrition
    
    def get_nutrition_for_ingredient(self, ingredient_name: str, amount: float, unit: str) -> Dict[str, float]:
        """获取单个食材的营养信息"""
        nutrition_info = self.nutrition_db.get(ingredient_name, {})
        
        # 单位转换
        if unit in ['千克', 'kg']:
            amount *= 1000
        elif unit in ['斤']:
            amount *= 500
        elif unit in ['两']:
            amount *= 50
        
        # 计算营养成分
        result = {}
        for key, value in nutrition_info.items():
            result[key] = (value * amount) / 100
        
        return result
```

#### 3.2.5 食谱解析工具

```python
# app/utils/recipe_parser.py
import re
from typing import Dict, Any, List

def parse_recipe_text(text: str) -> Dict[str, Any]:
    """解析AI生成的食谱文本"""
    recipe_data = {
        'title': '',
        'description': '',
        'difficulty': '',
        'cooking_time': 0,
        'ingredients': [],
        'steps': [],
        'nutrition_info': {},
        'tags': []
    }
    
    # 解析标题
    title_match = re.search(r'标题：([^\n]+)', text)
    if title_match:
        recipe_data['title'] = title_match.group(1).strip()
    
    # 解析描述
    desc_match = re.search(r'描述：([^\n]+)', text)
    if desc_match:
        recipe_data['description'] = desc_match.group(1).strip()
    
    # 解析难度
    difficulty_match = re.search(r'难度：([^\n]+)', text)
    if difficulty_match:
        recipe_data['difficulty'] = difficulty_match.group(1).strip()
    
    # 解析烹饪时间
    time_match = re.search(r'烹饪时间：(\d+)', text)
    if time_match:
        recipe_data['cooking_time'] = int(time_match.group(1))
    
    # 解析食材
    ingredients_section = re.search(r'食材：\s*([\s\S]*?)\s*步骤：', text)
    if ingredients_section:
        ingredients_text = ingredients_section.group(1)
        ingredient_lines = ingredients_text.strip().split('\n')
        for line in ingredient_lines:
            line = line.strip()
            if line and line.startswith('-'):
                # 提取食材名称、用量和单位
                # 格式：- 鸡肉 200 克
                parts = line[1:].strip().split()
                if len(parts) >= 3:
                    ingredient_data = {
                        'name': ' '.join(parts[:-2]),  # 食材名称可能包含空格
                        'amount': float(parts[-2]) if parts[-2].isdigit() else 0,
                        'unit': parts[-1]
                    }
                    recipe_data['ingredients'].append(ingredient_data)
    
    # 解析步骤
    steps_section = re.search(r'步骤：\s*([\s\S]*?)\s*营养成分', text)
    if steps_section:
        steps_text = steps_section.group(1)
        step_lines = steps_text.strip().split('\n')
        for line in step_lines:
            line = line.strip()
            if line and re.match(r'^\d+\.', line):
                # 提取步骤内容
                step_content = line.split('.', 1)[1].strip()
                recipe_data['steps'].append(step_content)
    
    # 解析营养成分
    nutrition_section = re.search(r'营养成分[^：]*：\s*([\s\S]*?)\s*标签：', text)
    if nutrition_section:
        nutrition_text = nutrition_section.group(1)
        nutrition_lines = nutrition_text.strip().split('\n')
        for line in nutrition_lines:
            line = line.strip()
            if line and line.startswith('-'):
                # 提取营养成分名称和值
                # 格式：- 卡路里：350卡
                parts = line[1:].strip().split('：')
                if len(parts) == 2:
                    name = parts[0].strip()
                    value_str = parts[1].strip()
                    
                    # 提取数值
                    value_match = re.search(r'(\d+)', value_str)
                    if value_match:
                        value = int(value_match.group(1))
                        # 映射到标准字段名
                        if '卡路里' in name or '热量' in name:
                            recipe_data['nutrition_info']['calories'] = value
                        elif '蛋白质' in name:
                            recipe_data['nutrition_info']['protein'] = value
                        elif '碳水' in name:
                            recipe_data['nutrition_info']['carbs'] = value
                        elif '脂肪' in name:
                            recipe_data['nutrition_info']['fat'] = value
    
    # 解析标签
    tags_match = re.search(r'标签：([^\n]+)', text)
    if tags_match:
        tags_text = tags_match.group(1).strip()
        recipe_data['tags'] = [tag.strip() for tag in tags_text.split(',')]
    
    return recipe_data
```

## 4. 项目文件目录结构

### 4.1 前端文件目录

```
frontend/                    # 前端应用根目录
├── public/                  # 静态资源文件
│   ├── index.html           # HTML入口文件
│   ├── favicon.ico          # 网站图标
│   └── manifest.json        # Web应用清单
├── src/                     # 源代码目录
│   ├── assets/              # 静态资源
│   │   ├── images/          # 图片资源
│   │   └── styles/          # 全局样式
│   ├── components/          # 通用组件
│   │   ├── common/          # 通用UI组件
│   │   │   ├── Button.tsx   # 自定义按钮
│   │   │   ├── Card.tsx     # 卡片组件
│   │   │   └── Input.tsx    # 输入框组件
│   │   ├── auth/            # 认证相关组件
│   │   │   ├── LoginForm.tsx
│   │   │   └── RegisterForm.tsx
│   │   └── recipe/          # 食谱相关组件
│   │       ├── IngredientInput.tsx
│   │       ├── RestrictionSelector.tsx
│   │       ├── PreferenceSettings.tsx
│   │       ├── RecipeGenerator.tsx
│   │       ├── RecipeCard.tsx
│   │       ├── RecipeDetail.tsx
│   │       ├── FavoriteButton.tsx
│   │       └── RatingStars.tsx
│   ├── layouts/             # 布局组件
│   │   ├── MainLayout.tsx   # 主布局
│   │   └── AuthLayout.tsx   # 认证页面布局
│   ├── pages/               # 页面组件
│   │   ├── HomePage.tsx     # 首页
│   │   ├── LoginPage.tsx    # 登录页
│   │   ├── RegisterPage.tsx # 注册页
│   │   ├── RecipeGeneratorPage.tsx
│   │   ├── RecipeListPage.tsx
│   │   ├── RecipeDetailPage.tsx
│   │   ├── ProfilePage.tsx  # 个人资料页
│   │   └── FavoritesPage.tsx # 收藏页
│   ├── routes/              # 路由配置
│   │   ├── index.tsx        # 路由入口
│   │   ├── PrivateRoute.tsx # 私有路由
│   │   └── PublicRoute.tsx  # 公共路由
│   ├── services/            # API服务
│   │   ├── api.ts           # API基础配置
│   │   ├── authService.ts   # 认证服务
│   │   ├── recipeService.ts # 食谱服务
│   │   └── userService.ts   # 用户服务
│   ├── store/               # Redux状态管理
│   │   ├── index.ts         # Store配置
│   │   ├── authSlice.ts     # 认证状态
│   │   ├── recipeSlice.ts   # 食谱状态
│   │   └── userSlice.ts     # 用户状态
│   ├── types/               # TypeScript类型定义
│   │   ├── index.ts         # 类型入口
│   │   ├── auth.ts          # 认证相关类型
│   │   ├── recipe.ts        # 食谱相关类型
│   │   └── user.ts          # 用户相关类型
│   ├── utils/               # 工具函数
│   │   ├── formatters.ts    # 格式化工具
│   │   ├── validators.ts    # 验证工具
│   │   └── constants.ts     # 常量定义
│   ├── hooks/               # 自定义Hooks
│   │   ├── useAuth.ts       # 认证Hook
│   │   ├── useRecipes.ts    # 食谱Hook
│   │   └── useFavorites.ts  # 收藏Hook
│   ├── App.tsx              # 应用主组件
│   ├── index.tsx            # 应用入口
│   └── react-app-env.d.ts   # React环境类型
├── .env                     # 环境变量
├── .env.development         # 开发环境变量
├── .env.production          # 生产环境变量
├── package.json             # 项目依赖
├── tsconfig.json            # TypeScript配置
├── eslintrc.json            # ESLint配置
├── prettierrc.json          # Prettier配置
└── README.md                # 项目说明
```

### 4.2 后端文件目录

```
backend/                    # 后端应用根目录
├── app/                    # 应用主目录
│   ├── api/                # API路由层
│   │   ├── __init__.py     # 初始化文件
│   │   ├── auth.py         # 认证相关路由
│   │   ├── recipes.py      # 食谱相关路由
│   │   ├── users.py        # 用户相关路由
│   │   └── deps.py         # 依赖项定义
│   ├── core/               # 核心配置
│   │   ├── __init__.py     # 初始化文件
│   │   ├── config.py       # 配置管理
│   │   ├── database.py     # 数据库连接
│   │   └── security.py     # 安全相关功能
│   ├── models/             # 数据库模型
│   │   ├── __init__.py     # 初始化文件
│   │   ├── user.py         # 用户模型
│   │   ├── recipe.py       # 食谱模型
│   │   ├── favorite.py     # 收藏模型
│   │   ├── rating.py       # 评分模型
│   │   └── ingredient.py   # 食材模型
│   ├── schemas/            # 数据传输对象
│   │   ├── __init__.py     # 初始化文件
│   │   ├── auth.py         # 认证相关DTO
│   │   ├── recipe.py       # 食谱相关DTO
│   │   ├── user.py         # 用户相关DTO
│   │   └── common.py       # 通用DTO
│   ├── services/           # 业务服务层
│   │   ├── __init__.py     # 初始化文件
│   │   ├── auth_service.py # 认证服务
│   │   ├── recipe_service.py # 食谱服务
│   │   ├── user_service.py # 用户服务
│   │   ├── ai_service.py   # AI调用服务
│   │   └── nutrition_service.py # 营养计算服务
│   ├── utils/              # 工具函数
│   │   ├── __init__.py     # 初始化文件
│   │   ├── recipe_parser.py # 食谱解析工具
│   │   └── response_formatter.py # 响应格式化工具
│   └── __init__.py         # 应用初始化
├── alembic/                # 数据库迁移
│   ├── env.py              # Alembic环境配置
│   ├── script.py.mako      # 迁移脚本模板
│   └── versions/           # 迁移版本文件
├── main.py                 # 应用入口
├── requirements.txt        # Python依赖
├── .env                    # 环境变量
├── .env.development        # 开发环境变量
├── .env.production         # 生产环境变量
├── start.sh                # 启动脚本
├── Dockerfile              # Docker配置
└── README.md               # 项目说明
```

### 4.3 项目根目录

```
Vers_3/                     # 项目根目录
├── frontend/               # 前端应用
├── backend/                # 后端应用
├── docker-compose.yml      # Docker Compose配置
├── .gitignore              # Git忽略文件
└── README.md               # 项目总体说明
```

## 5. 部署与配置

### 5.1 环境变量配置

**前端环境变量 (.env)**:
```
REACT_APP_API_BASE_URL=http://localhost:8000/api
REACT_APP_AUTH_TOKEN_KEY=access_token
```

**后端环境变量 (.env)**:
```
# 数据库配置
DATABASE_URL=postgresql://admin:password@localhost:5432/example_db

# 安全配置
SECRET_KEY=your-secret-key-here
ALGORITHM=HS256
ACCESS_TOKEN_EXPIRE_MINUTES=30

# 阿里通义千问API配置
QIANWEN_API_KEY=your-qianwen-api-key
QIANWEN_API_BASE_URL=https://apiqianwen.com/v1/chat/completions

# 应用配置
APP_NAME=Recipe Generator
DEBUG=True
```

### 5.2 Docker配置

**docker-compose.yml**:
```yaml
version: '3.8'

services:
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    ports:
      - "3000:3000"
    environment:
      - REACT_APP_API_BASE_URL=http://localhost:8000/api
    depends_on:
      - backend

  backend:
    build