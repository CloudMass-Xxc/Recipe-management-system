# 个性化食谱管理系统 - 编码阶段开发建议文档

## 1. 文档概述

### 1.1 目的
本文档基于已完成的需求分析、概要设计和详细设计，为个性化食谱管理系统的编码阶段提供全面的开发建议和指导，帮助开发团队高效、高质量地完成系统实现。

### 1.2 适用范围
本文档适用于参与个性化食谱管理系统开发的所有团队成员，包括前端开发、后端开发、数据库工程师和测试人员。

## 2. 编码阶段整体策略

### 2.1 开发方法论选择
基于项目规模和团队情况，建议采用**敏捷开发**方法论，结合**特性驱动开发(Feature Driven Development)**的思想：

- 以2-3周为一个迭代周期
- 每个迭代交付可测试的功能模块
- 迭代结束进行代码审查和功能演示
- 根据反馈调整后续迭代计划

### 2.2 数据库与代码开发顺序

**推荐采用"数据库优先，核心API优先"的开发策略**：

1. **先设计并实现数据库**：
   - 数据库是整个系统的基础，决定了数据模型和关系
   - 前端UI和业务逻辑都依赖于数据结构
   - 提前确定数据库结构可以避免后期大规模重构

2. **然后开发核心API**：
   - 实现核心业务逻辑和数据访问层
   - 为前端开发提供稳定的接口

3. **最后开发前端界面**：
   - 基于稳定的API进行UI实现
   - 分模块逐步构建用户界面

## 3. 编码阶段详细步骤

### 3.1 准备阶段（1-2天）

#### 3.1.1 开发环境搭建

**前端环境**：
```bash
# 使用Vite创建React项目
npm create vite@latest frontend -- --template react-ts
cd frontend
# 安装核心依赖
npm install axios react-router-dom@6 @reduxjs/toolkit react-redux styled-components
```

**后端环境**：
```bash
# 创建后端项目目录
mkdir backend
cd backend
# 初始化Node.js项目
npm init -y
# 安装核心依赖
npm install express @prisma/client bcrypt jsonwebtoken cors dotenv
# 安装开发依赖
npm install -D typescript ts-node-dev @types/node @types/express @types/bcrypt @types/jsonwebtoken @types/cors prisma
```

#### 3.1.2 项目结构创建

根据之前设计的项目文件目录结构，创建基本的目录和文件：

**前端目录结构**：
```
frontend/
├── public/
├── src/
│   ├── components/       # 通用组件
│   ├── pages/            # 页面组件
│   ├── services/         # API服务
│   ├── store/            # Redux状态管理
│   ├── hooks/            # 自定义Hooks
│   ├── utils/            # 工具函数
│   ├── assets/           # 静态资源
│   ├── App.tsx
│   ├── main.tsx
│   └── index.css
├── package.json
├── tsconfig.json
└── vite.config.ts
```

**后端目录结构**：
```
backend/
├── src/
│   ├── controllers/      # 控制器
│   ├── services/         # 业务逻辑
│   ├── repositories/     # 数据访问层
│   ├── models/           # 数据模型
│   ├── routes/           # 路由定义
│   ├── middleware/       # 中间件
│   ├── utils/            # 工具函数
│   ├── config/           # 配置文件
│   └── app.ts            # 应用入口
├── prisma/               # Prisma配置
├── package.json
├── tsconfig.json
└── .env                  # 环境变量
```

### 3.2 数据库实现阶段（3-5天）

#### 3.2.1 数据库设计实现

1. **根据数据库设计文档创建Prisma Schema**：
```prisma
// prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// 定义User模型
model User {
  user_id           String    @id @default(uuid()) @db.Uuid
  username          String    @unique @db.VarChar(100)
  email             String    @unique @db.VarChar(255)
  password_hash     String    @db.VarChar(255)
  diet_preferences  Json?     @default({})
  is_active         String    @default("Y") @db.Char(1)
  created_at        DateTime  @default(now()) @db.Timestamptz
  updated_at        DateTime  @default(now()) @updatedAt @db.Timestamptz
  favorites         Favorite[]
  ratings           Rating[]
  diet_plans        DietPlan[]
}

// 定义其他模型...
```

2. **创建数据库迁移**：
```bash
npx prisma migrate dev --name init
```

3. **生成Prisma客户端**：
```bash
npx prisma generate
```

#### 3.2.2 数据库初始化脚本

创建数据库初始化脚本，包括基础数据和测试数据：
```typescript
// src/utils/initDatabase.ts
import prisma from '../config/db';

async function initDatabase() {
  // 初始化食材类别和基础食材数据
  const categories = ['蔬菜', '水果', '肉类', '海鲜', '谷物', '豆类', '乳制品', '调味品'];
  
  // 批量创建食材类别
  for (const category of categories) {
    await prisma.ingredientCategory.create({
      data: { name: category }
    });
  }
  
  console.log('数据库初始化完成');
}

export default initDatabase;
```

### 3.3 后端核心功能开发（1-2周）

#### 3.3.1 用户认证模块

1. **实现用户注册和登录API**：
```typescript
// src/controllers/authController.ts
import { Request, Response } from 'express';
import bcrypt from 'bcrypt';
import jwt from 'jsonwebtoken';
import prisma from '../config/db';

export const register = async (req: Request, res: Response) => {
  try {
    const { username, email, password } = req.body;
    
    // 检查用户是否已存在
    const existingUser = await prisma.user.findUnique({ where: { email } });
    if (existingUser) {
      return res.status(400).json({ message: '用户已存在' });
    }
    
    // 密码加密
    const salt = await bcrypt.genSalt(10);
    const passwordHash = await bcrypt.hash(password, salt);
    
    // 创建用户
    const user = await prisma.user.create({
      data: {
        username,
        email,
        password_hash: passwordHash
      }
    });
    
    // 生成JWT token
    const token = jwt.sign(
      { userId: user.user_id },
      process.env.JWT_SECRET || 'your-secret-key',
      { expiresIn: '7d' }
    );
    
    res.status(201).json({ user, token });
  } catch (error) {
    res.status(500).json({ message: '服务器错误', error });
  }
};
```

2. **实现认证中间件**：
```typescript
// src/middleware/auth.ts
import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';

interface AuthRequest extends Request {
  user?: any;
}

export const authMiddleware = async (req: AuthRequest, res: Response, next: NextFunction) => {
  try {
    const token = req.headers.authorization?.split(' ')[1];
    
    if (!token) {
      return res.status(401).json({ message: '未提供认证token' });
    }
    
    const decoded = jwt.verify(token, process.env.JWT_SECRET || 'your-secret-key');
    req.user = decoded;
    next();
  } catch (error) {
    res.status(401).json({ message: '无效的认证token' });
  }
};
```

#### 3.3.2 食谱管理核心API

1. **实现食谱生成API**：
```typescript
// src/controllers/recipeController.ts
import { Request, Response } from 'express';
import prisma from '../config/db';

interface AuthRequest extends Request {
  user?: any;
}

export const generateRecipe = async (req: AuthRequest, res: Response) => {
  try {
    const { ingredients, preferences, dietaryRestrictions } = req.body;
    const userId = req.user?.userId;
    
    // 这里实现基于用户输入生成食谱的逻辑
    // 可以调用外部AI服务或使用内部算法
    const generatedRecipe = await generateRecipeWithAI(ingredients, preferences, dietaryRestrictions);
    
    // 保存生成的食谱
    const recipe = await prisma.recipe.create({
      data: {
        title: generatedRecipe.title,
        description: generatedRecipe.description,
        ingredients: generatedRecipe.ingredients,
        steps: generatedRecipe.steps,
        cooking_time: generatedRecipe.cookingTime,
        difficulty: generatedRecipe.difficulty,
        nutrition_info: generatedRecipe.nutritionInfo,
        tags: generatedRecipe.tags
      }
    });
    
    res.status(201).json(recipe);
  } catch (error) {
    res.status(500).json({ message: '生成食谱失败', error });
  }
};
```

2. **实现食谱搜索和筛选API**：
```typescript
export const searchRecipes = async (req: Request, res: Response) => {
  try {
    const { query, tags, difficulty, maxCookingTime } = req.query;
    
    const searchParams: any = {};
    
    if (query) {
      // 使用全文搜索
      searchParams.OR = [
        { title: { contains: query as string, mode: 'insensitive' } },
        { description: { contains: query as string, mode: 'insensitive' } }
      ];
    }
    
    if (tags) {
      // 标签筛选
      const tagArray = (tags as string).split(',');
      searchParams.tags = { hasSome: tagArray };
    }
    
    if (difficulty) {
      searchParams.difficulty = difficulty;
    }
    
    if (maxCookingTime) {
      searchParams.cooking_time = { lte: parseInt(maxCookingTime as string) };
    }
    
    const recipes = await prisma.recipe.findMany({
      where: searchParams,
      take: 20,
      orderBy: { created_at: 'desc' }
    });
    
    res.json(recipes);
  } catch (error) {
    res.status(500).json({ message: '搜索食谱失败', error });
  }
};
```

### 3.4 前端核心功能开发（2-3周）

#### 3.4.1 前端路由和Redux配置

1. **配置React Router**：
```typescript
// src/App.tsx
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
import LoginPage from './pages/LoginPage';
import RegisterPage from './pages/RegisterPage';
import HomePage from './pages/HomePage';
import RecipeGeneratorPage from './pages/RecipeGeneratorPage';
import RecipeDetailPage from './pages/RecipeDetailPage';
import UserProfilePage from './pages/UserProfilePage';
import ProtectedRoute from './components/ProtectedRoute';

function App() {
  return (
    <Router>
      <Routes>
        <Route path="/login" element={<LoginPage />} />
        <Route path="/register" element={<RegisterPage />} />
        <Route path="/" element={<HomePage />} />
        <Route 
          path="/generate" 
          element={
            <ProtectedRoute>
              <RecipeGeneratorPage />
            </ProtectedRoute>
          } 
        />
        <Route path="/recipe/:id" element={<RecipeDetailPage />} />
        <Route 
          path="/profile" 
          element={
            <ProtectedRoute>
              <UserProfilePage />
            </ProtectedRoute>
          } 
        />
      </Routes>
    </Router>
  );
}

export default App;
```

2. **配置Redux Store**：
```typescript
// src/store/index.ts
import { configureStore } from '@reduxjs/toolkit';
import userReducer from './slices/userSlice';
import recipeReducer from './slices/recipeSlice';

export const store = configureStore({
  reducer: {
    user: userReducer,
    recipe: recipeReducer,
  },
});

export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;
```

#### 3.4.2 用户认证页面

1. **实现登录组件**：
```tsx
// src/pages/LoginPage.tsx
import React, { useState } from 'react';
import { useDispatch } from 'react-redux';
import { useNavigate } from 'react-router-dom';
import { loginUser } from '../store/slices/userSlice';
import styled from 'styled-components';

const LoginContainer = styled.div`
  max-width: 400px;
  margin: 0 auto;
  padding: 2rem;
  box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
  border-radius: 8px;
`;

const LoginForm = styled.form`
  display: flex;
  flex-direction: column;
  gap: 1rem;
`;

const Input = styled.input`
  padding: 0.75rem;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-size: 1rem;
`;

const Button = styled.button`
  padding: 0.75rem;
  background-color: #4caf50;
  color: white;
  border: none;
  border-radius: 4px;
  font-size: 1rem;
  cursor: pointer;
  
  &:hover {
    background-color: #45a049;
  }
`;

const LoginPage: React.FC = () => {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  const dispatch = useDispatch();
  const navigate = useNavigate();

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      await dispatch(loginUser({ email, password })).unwrap();
      navigate('/');
    } catch (err: any) {
      setError(err.message || '登录失败');
    }
  };

  return (
    <LoginContainer>
      <h2>登录</h2>
      {error && <div style={{ color: 'red' }}>{error}</div>}
      <LoginForm onSubmit={handleSubmit}>
        <div>
          <label htmlFor="email">邮箱</label>
          <Input
            id="email"
            type="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            required
          />
        </div>
        <div>
          <label htmlFor="password">密码</label>
          <Input
            id="password"
            type="password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            required
          />
        </div>
        <Button type="submit">登录</Button>
      </LoginForm>
    </LoginContainer>
  );
};

export default LoginPage;
```

#### 3.4.3 食谱生成功能

实现食谱生成页面，包括食材输入、饮食偏好设置等功能：
```tsx
// src/pages/RecipeGeneratorPage.tsx
import React, { useState } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { generateRecipe } from '../store/slices/recipeSlice';
import { RootState } from '../store';
import styled from 'styled-components';

const GeneratorContainer = styled.div`
  max-width: 800px;
  margin: 0 auto;
  padding: 2rem;
`;

const FormSection = styled.section`
  margin-bottom: 2rem;
  padding: 1rem;
  border: 1px solid #ddd;
  border-radius: 8px;
`;

const IngredientInput = styled.div`
  display: flex;
  gap: 0.5rem;
  margin-bottom: 0.5rem;
`;

const GeneratorPage: React.FC = () => {
  const [ingredients, setIngredients] = useState<string[]>(['']);
  const [preferences, setPreferences] = useState<string[]>([]);
  const [dietaryRestrictions, setDietaryRestrictions] = useState<string[]>([]);
  const dispatch = useDispatch();
  const { loading, error, generatedRecipes } = useSelector((state: RootState) => state.recipe);

  const handleAddIngredient = () => {
    setIngredients([...ingredients, '']);
  };

  const handleIngredientChange = (index: number, value: string) => {
    const newIngredients = [...ingredients];
    newIngredients[index] = value;
    setIngredients(newIngredients);
  };

  const handleGenerate = () => {
    const validIngredients = ingredients.filter(ing => ing.trim() !== '');
    dispatch(generateRecipe({
      ingredients: validIngredients,
      preferences,
      dietaryRestrictions
    }));
  };

  return (
    <GeneratorContainer>
      <h1>智能食谱生成器</h1>
      
      <FormSection>
        <h2>添加食材</h2>
        {ingredients.map((ingredient, index) => (
          <IngredientInput key={index}>
            <input
              type="text"
              value={ingredient}
              onChange={(e) => handleIngredientChange(index, e.target.value)}
              placeholder="输入食材名称"
            />
          </IngredientInput>
        ))}
        <button onClick={handleAddIngredient}>添加食材</button>
      </FormSection>

      <FormSection>
        <h2>饮食偏好</h2>
        {/* 饮食偏好选择组件 */}
      </FormSection>

      <button onClick={handleGenerate} disabled={loading}>
        {loading ? '生成中...' : '生成食谱'}
      </button>

      {error && <div style={{ color: 'red' }}>{error}</div>}
      
      {generatedRecipes && generatedRecipes.length > 0 && (
        <div>
          <h2>生成的食谱</h2>
          {/* 显示生成的食谱 */}
        </div>
      )}
    </GeneratorContainer>
  );
};

export default GeneratorPage;
```

### 3.5 集成测试阶段（1-2周）

#### 3.5.1 API测试

使用Jest和Supertest进行API测试：
```typescript
// tests/api/auth.test.ts
import request from 'supertest';
import app from '../../src/app';
import prisma from '../../src/config/db';

describe('Auth API', () => {
  beforeEach(async () => {
    // 清理测试数据
    await prisma.user.deleteMany();
  });

  afterAll(async () => {
    await prisma.$disconnect();
  });

  test('用户注册应该成功并返回用户信息和token', async () => {
    const response = await request(app)
      .post('/api/auth/register')
      .send({
        username: 'testuser',
        email: 'test@example.com',
        password: 'password123'
      })
      .expect(201);

    expect(response.body.user).toBeDefined();
    expect(response.body.token).toBeDefined();
    expect(response.body.user.username).toBe('testuser');
  });

  test('用户登录应该成功并返回用户信息和token', async () => {
    // 先注册一个用户
    await request(app)
      .post('/api/auth/register')
      .send({
        username: 'testuser',
        email: 'test@example.com',
        password: 'password123'
      });

    // 然后登录
    const response = await request(app)
      .post('/api/auth/login')
      .send({
        email: 'test@example.com',
        password: 'password123'
      })
      .expect(200);

    expect(response.body.user).toBeDefined();
    expect(response.body.token).toBeDefined();
  });
});
```

#### 3.5.2 前端组件测试

使用Jest和React Testing Library进行组件测试：
```typescript
// tests/components/LoginForm.test.tsx
import React from 'react';
import { render, screen, fireEvent } from '@testing-library/react';
import { Provider } from 'react-redux';
import { store } from '../../src/store';
import LoginPage from '../../src/pages/LoginPage';

describe('LoginPage', () => {
  test('应该渲染登录表单', () => {
    render(
      <Provider store={store}>
        <LoginPage />
      </Provider>
    );
    
    expect(screen.getByLabelText(/邮箱/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/密码/i)).toBeInTheDocument();
    expect(screen.getByRole('button', { name: /登录/i })).toBeInTheDocument();
  });

  test('表单提交应该调用登录函数', () => {
    // 测试表单提交逻辑
  });
});
```

### 3.6 优化与部署准备（1周）

#### 3.6.1 性能优化

1. **前端优化**：
   - 使用React.lazy和Suspense实现代码分割
   - 优化图片加载，使用延迟加载
   - 优化Redux状态管理，避免不必要的渲染
   - 实现API响应缓存

2. **后端优化**：
   - 实现API缓存
   - 优化数据库查询，添加适当的索引
   - 使用连接池管理数据库连接
   - 实现请求限流

#### 3.6.2 部署配置

1. **创建Docker Compose配置**：
```yaml
# docker-compose.yml
version: '3'

services:
  frontend:
    build: ./frontend
    ports:
      - "3000:80"
    depends_on:
      - backend

  backend:
    build: ./backend
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql://admin:password@db:5432/example_db
      - JWT_SECRET=your-secret-key
    depends_on:
      - db

  db:
    image: postgres:14
    ports:
      - "5432:5432"
    environment:
      - POSTGRES_USER=admin
      - POSTGRES_PASSWORD=password
      - POSTGRES_DB=example_db
    volumes:
      - postgres_data:/var/lib/postgresql/data

volumes:
  postgres_data:
```

2. **创建Dockerfile**：

**前端Dockerfile**：
```dockerfile
# frontend/Dockerfile
FROM node:16-alpine as build
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
RUN npm run build

FROM nginx:alpine
COPY --from=build /app/dist /usr/share/nginx/html
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
```

**后端Dockerfile**：
```dockerfile
# backend/Dockerfile
FROM node:16-alpine
WORKDIR /app
COPY package*.json ./
RUN npm install
COPY . .
RUN npx prisma generate
EXPOSE 8000
CMD ["npm", "start"]
```

## 4. 编码阶段最佳实践

### 4.1 代码规范

1. **TypeScript规范**：
   - 使用强类型，避免使用any
   - 使用接口定义对象结构
   - 使用类型守卫处理条件类型

2. **React规范**：
   - 组件命名使用PascalCase
   - 文件命名与组件名保持一致
   - 使用函数式组件和Hooks
   - 合理使用React.memo避免不必要的重渲染

3. **后端规范**：
   - 使用中间件处理通用逻辑
   - 采用RESTful API设计风格
   - 使用依赖注入模式管理服务

### 4.2 代码审查流程

1. **审查准备**：
   - 开发者完成功能开发和自测
   - 编写单元测试和集成测试
   - 确保代码通过lint检查

2. **审查重点**：
   - 代码质量和可维护性
   - 安全漏洞和潜在问题
   - 性能优化机会
   - 功能实现是否符合需求

3. **审查工具**：
   - 使用ESLint和Prettier进行代码风格检查
   - 使用SonarQube进行代码质量分析
   - 使用GitHub/GitLab的PR/MR功能进行代码审查

### 4.3 常见问题及解决方案

1. **性能问题**：
   - 问题：前端页面加载缓慢
   - 解决方案：实现代码分割、图片优化、API响应缓存

2. **安全问题**：
   - 问题：SQL注入、XSS攻击
   - 解决方案：使用ORM、参数化查询、输入验证、输出转义

3. **数据库问题**：
   - 问题：查询性能下降
   - 解决方案：优化查询语句、添加适当索引、使用连接池

4. **部署问题**：
   - 问题：环境配置不一致
   - 解决方案：使用Docker容器化、环境变量配置

## 5. 总结

本文档详细介绍了个性化食谱管理系统编码阶段的开发步骤和最佳实践。遵循"数据库优先，核心API优先"的开发策略，可以确保系统开发的高效性和代码质量。

在编码过程中，团队应该注重代码规范、单元测试和代码审查，确保系统的可维护性和稳定性。同时，性能优化和安全考虑应该贯穿整个开发过程，为用户提供高质量的使用体验。

最后，通过Docker容器化技术，可以实现开发、测试和生产环境的一致性，简化部署流程，提高系统的可靠性。